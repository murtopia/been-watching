'use client'

import { useEffect, useState } from 'react'
import { createClient } from '@/utils/supabase/client'
import { useRouter, useSearchParams } from 'next/navigation'
import BottomNav from '@/components/navigation/BottomNav'
import AppHeader from '@/components/navigation/AppHeader'
import ActivityCard from '@/components/feed/ActivityCard'
import RecommendationCard from '@/components/feed/RecommendationCard'
import ReleaseNotificationCard from '@/components/feed/ReleaseNotificationCard'
import SearchModal from '@/components/search/SearchModal'
import MediaDetailModal from '@/components/media/MediaDetailModal'
import ProfileSetup from '@/components/onboarding/ProfileSetup'
import InviteCodeGate from '@/components/onboarding/InviteCodeGate'
import Footer from '@/components/navigation/Footer'
import { Sparkles } from 'lucide-react'
import { isAutoGeneratedUsername } from '@/utils/usernameValidation'
import { safeFormatDate } from '@/utils/dateFormatting'
import { trackUserSignedUp, trackUserLoggedIn, identifyUser, trackActivityLiked, trackActivityUnliked, trackActivityCommented, trackFeedViewed } from '@/utils/analytics'

export default function HomePage() {
  const [user, setUser] = useState<any>(null)
  const [profile, setProfile] = useState<any>(null)
  const [showInviteCodeGate, setShowInviteCodeGate] = useState(false)
  const [showProfileSetup, setShowProfileSetup] = useState(false)
  const [feedItems, setFeedItems] = useState<any[]>([])
  const [loading, setLoading] = useState(true)
  const [hasMore, setHasMore] = useState(true)
  const [offset, setOffset] = useState(0)
  const [searchOpen, setSearchOpen] = useState(false)
  const [detailModalOpen, setDetailModalOpen] = useState(false)
  const [selectedMedia, setSelectedMedia] = useState<any>(null)
  const router = useRouter()
  const searchParams = useSearchParams()
  const supabase = createClient()

  useEffect(() => {
    checkUser()

    // Handle OAuth callback tracking
    const oauthCallback = searchParams.get('oauth_callback')
    const oauthAction = searchParams.get('oauth_action')
    const userId = searchParams.get('user_id')

    if (oauthCallback === 'true' && userId) {
      // Track OAuth event
      if (oauthAction === 'signup') {
        identifyUser(userId, {
          signup_date: new Date().toISOString()
        })
        trackUserSignedUp({
          signup_method: 'google',
          username: 'oauth_user'
        })
      } else if (oauthAction === 'login') {
        identifyUser(userId)
        trackUserLoggedIn({
          login_method: 'oauth'
        })
      }

      // Clean up URL params
      const url = new URL(window.location.href)
      url.searchParams.delete('oauth_callback')
      url.searchParams.delete('oauth_action')
      url.searchParams.delete('user_id')
      window.history.replaceState({}, '', url.toString())
    }
  }, [])

  useEffect(() => {
    if (user && !showInviteCodeGate && !showProfileSetup) {
      loadFeed(true) // Reset feed
    }
  }, [user, showInviteCodeGate, showProfileSetup])

  // Infinite scroll setup
  useEffect(() => {
    if (!user || showInviteCodeGate || showProfileSetup) return

    const observer = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting && hasMore && !loading) {
          loadFeed(false) // Load more
        }
      },
      { threshold: 0.1 }
    )

    const sentinel = document.getElementById('feed-sentinel')
    if (sentinel) {
      observer.observe(sentinel)
    }

    return () => {
      if (sentinel) {
        observer.unobserve(sentinel)
      }
    }
  }, [user, hasMore, loading, showInviteCodeGate, showProfileSetup])

  const checkUser = async () => {
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) {
      router.push('/') // Redirect to new public landing page
    } else {
      setUser(user)

      // Check if profile is set up
      const { data: profileData, error: profileError } = await supabase
        .from('profiles')
        .select('*')
        .eq('id', user.id)
        .single()

      if (profileData) {
        setProfile(profileData)

        // Check if user needs to provide invite code (OAuth users who haven't been approved)
        if (!profileData.is_approved) {
          setShowInviteCodeGate(true)
        }
        // Check if username needs to be customized (auto-generated with timestamp, etc.)
        else if (!profileData.username || isAutoGeneratedUsername(profileData.username)) {
          setShowProfileSetup(true)
        }
      } else if (profileError) {
        // Profile doesn't exist, create it (shouldn't happen with trigger, but fallback)
        const defaultUsername = user.email?.split('@')[0] || 'user'
        // Add timestamp to make username unique
        const uniqueUsername = `${defaultUsername}_${Date.now()}`
        const { data: newProfile, error: createError } = await supabase
          .from('profiles')
          .insert({
            id: user.id,
            user_id: user.id,
            username: uniqueUsername,
            display_name: defaultUsername
          })
          .select()
          .single()

        if (createError) {
          console.error('Error creating profile:', createError)
        } else if (newProfile) {
          setProfile(newProfile)
          // New OAuth user needs invite code
          setShowInviteCodeGate(true)
        }
      }
    }
  }

  const loadFeed = async (reset: boolean = false) => {
    try {
      if (reset) {
        setLoading(true)
        setOffset(0)
        setFeedItems([])
      }

      const currentOffset = reset ? 0 : offset
      const limit = 20

      const response = await fetch(`/api/feed?limit=${limit}&offset=${currentOffset}`)
      
      if (!response.ok) {
        throw new Error('Failed to load feed')
      }

      const data = await response.json()

      if (data.items && data.items.length > 0) {
        // Enrich feed items with additional data (comments, likes, user ratings)
        const enrichedItems = await Promise.all(
          data.items.map(async (item: any) => {
            // For activities, get full comment/like data
            if (item.type === 'activity') {
              // Get comments
              const { data: comments } = await supabase
                .from('comments')
                .select(`
                  id,
                  comment_text,
                  user_id,
                  created_at,
                  user:profiles!comments_user_id_fkey (
                    id,
                    display_name,
                    avatar_url
                  )
                `)
                .eq('activity_id', item.id)
                .order('created_at', { ascending: true })

              // Get likes
              const { data: likes } = await supabase
                .from('activity_likes')
                .select(`
                  id,
                  user:profiles!activity_likes_user_id_fkey (
                    id,
                    display_name,
                    avatar_url
                  )
                `)
                .eq('activity_id', item.id)

              // Get user's rating/status for this media
              const { data: userRating } = await supabase
                .from('ratings')
                .select('rating')
                .eq('user_id', user?.id)
                .eq('media_id', item.media?.id)
                .maybeSingle()

              const { data: userWatchStatus } = await supabase
                .from('watch_status')
                .select('status')
                .eq('user_id', user?.id)
                .eq('media_id', item.media?.id)
                .maybeSingle()

              return {
                ...item,
                comments: comments || [],
                likes: likes || [],
                user_rating: userRating?.rating || null,
                user_status: userWatchStatus?.status || null
              }
            }
            
            // For recommendations and releases, get user's rating/status
            if (item.type === 'recommendation' || item.type === 'release_notification') {
              const { data: userRating } = await supabase
                .from('ratings')
                .select('rating')
                .eq('user_id', user?.id)
                .eq('media_id', item.media?.id)
                .maybeSingle()

              const { data: userWatchStatus } = await supabase
                .from('watch_status')
                .select('status')
                .eq('user_id', user?.id)
                .eq('media_id', item.media?.id)
                .maybeSingle()

              return {
                ...item,
                user_rating: userRating?.rating || null,
                user_status: userWatchStatus?.status || null
              }
            }

            return item
          })
        )

        if (reset) {
          setFeedItems(enrichedItems)
        } else {
          setFeedItems(prev => [...prev, ...enrichedItems])
        }

        setOffset(currentOffset + data.items.length)
        setHasMore(data.hasMore)

        // Track feed view
        trackFeedViewed({
          feed_type: 'enhanced',
          items_shown: enrichedItems.length
        })
      } else {
        if (reset) {
          setFeedItems([])
        }
        setHasMore(false)
      }
    } catch (error) {
      console.error('Error loading feed:', error)
    } finally {
      setLoading(false)
    }
  }

  const handleLike = async (activityId: string) => {
    if (!user) return

    // Find the activity in current state
    const activityIndex = feedItems.findIndex(a => a.type === 'activity' && a.id === activityId)
    if (activityIndex === -1) return

    const currentActivity = feedItems[activityIndex]
    const wasLiked = currentActivity.user_liked

    // OPTIMISTIC UPDATE - Update UI immediately
    const optimisticItems = [...feedItems]
    optimisticItems[activityIndex] = {
      ...currentActivity,
      user_liked: !wasLiked,
      like_count: wasLiked ? currentActivity.like_count - 1 : currentActivity.like_count + 1
    }
    setFeedItems(optimisticItems)

    try {
      // Get the activity to find the owner
      const { data: activity } = await supabase
        .from('activities')
        .select('user_id')
        .eq('id', activityId)
        .single()

      // Check if already liked
      const { data: existingLike } = await supabase
        .from('activity_likes')
        .select('id')
        .eq('activity_id', activityId)
        .eq('user_id', user.id)
        .maybeSingle()

      if (existingLike) {
        // Unlike - also delete the notification
        await supabase
          .from('activity_likes')
          .delete()
          .eq('id', existingLike.id)

        await supabase
          .from('notifications')
          .delete()
          .eq('activity_id', activityId)
          .eq('actor_id', user.id)
          .eq('type', 'like_activity')

        // Track unlike event
        trackActivityUnliked({
          activity_id: activityId
        })
      } else {
        // Like
        await supabase
          .from('activity_likes')
          .insert({
            activity_id: activityId,
            user_id: user.id
          })

        // Create notification for activity owner (don't notify yourself)
        if (activity && activity.user_id !== user.id) {
          await supabase
            .from('notifications')
            .insert({
              user_id: activity.user_id,
              actor_id: user.id,
              type: 'like_activity',
              target_type: 'activity',
              target_id: activityId,
              activity_id: activityId
            })
        }

        // Track like event
        trackActivityLiked({
          activity_id: activityId,
          activity_type: currentActivity.activity_type,
          activity_user_id: currentActivity.user?.id || activity?.user_id || '',
          activity_username: currentActivity.user?.username || ''
        })
      }

      // Reload feed in background to sync any other changes
      loadFeed(true)
    } catch (error) {
      console.error('Error handling like:', error)
      // ROLLBACK on error - restore previous state
      setFeedItems(feedItems)
    }
  }

  const handleComment = async (activityId: string, comment: string) => {
    if (!user || !comment.trim()) return

    try {
      // Get the activity to find the owner and type
      const { data: activity } = await supabase
        .from('activities')
        .select('user_id, activity_type')
        .eq('id', activityId)
        .single()

      // Insert comment
      await supabase
        .from('comments')
        .insert({
          activity_id: activityId,
          user_id: user.id,
          comment_text: comment.trim()
        })

      // Create notification for activity owner (don't notify yourself)
      if (activity && activity.user_id !== user.id) {
        await supabase
          .from('notifications')
          .insert({
            user_id: activity.user_id,
            actor_id: user.id,
            type: 'comment',
            target_type: 'activity',
            target_id: activityId,
            activity_id: activityId
          })
      }

      // Track comment event
      const hasMentions = comment.includes('@')
      trackActivityCommented({
        activity_id: activityId,
        activity_type: activity?.activity_type || '',
        comment_length: comment.trim().length,
        has_mentions: hasMentions
      })

      // Reload feed to update counts
      loadFeed(true)
    } catch (error) {
      console.error('Error posting comment:', error)
    }
  }

  const handleQuickRate = async (mediaId: string, rating: string) => {
    if (!user) return

    try {
      const { error: ratingError } = await supabase
        .from('ratings')
        .upsert({
          user_id: user.id,
          media_id: mediaId,
          rating: rating,
          my_take: null
        }, { onConflict: 'user_id,media_id' })

      if (ratingError) {
        console.error('Error saving rating:', ratingError)
      } else {
        // Reload feed to show updated rating
        loadFeed(true)
      }
    } catch (error) {
      console.error('Error handling quick rate:', error)
    }
  }

  const handleQuickStatus = async (mediaId: string, status: string) => {
    if (!user) return

    try {
      const { error: statusError } = await supabase
        .from('watch_status')
        .upsert({
          user_id: user.id,
          media_id: mediaId,
          status: status
        }, { onConflict: 'user_id,media_id' })

      if (statusError) {
        console.error('Error saving status:', statusError)
      } else {
        // Reload feed to show updated status
        loadFeed(true)
      }
    } catch (error) {
      console.error('Error handling quick status:', error)
    }
  }

  const handleDeleteComment = async (commentId: string) => {
    if (!user) return

    try {
      const { error } = await supabase
        .from('comments')
        .delete()
        .eq('id', commentId)
        .eq('user_id', user.id) // Only allow deleting your own comments

      if (error) {
        console.error('Error deleting comment:', error)
      } else {
        // Reload feed to update comment count
        loadFeed(true)
      }
    } catch (error) {
      console.error('Error deleting comment:', error)
    }
  }

  const handleDismissRecommendation = async (recommendationId: string) => {
    if (!user) return

    try {
      // Mark as interacted (dismissed)
      await supabase
        .from('recommendations')
        .update({ interacted_at: new Date().toISOString() })
        .eq('id', recommendationId)
        .eq('user_id', user.id)

      // Remove from feed
      setFeedItems(prev => prev.filter(item => 
        !(item.type === 'recommendation' && item.id === recommendationId)
      ))
    } catch (error) {
      console.error('Error dismissing recommendation:', error)
    }
  }

  const handleMarkReleaseSeen = async (releaseId: string) => {
    if (!user) return

    try {
      await fetch('/api/releases/upcoming', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ notificationId: releaseId })
      })

      // Remove from feed
      setFeedItems(prev => prev.filter(item => 
        !(item.type === 'release_notification' && item.id === releaseId)
      ))
    } catch (error) {
      console.error('Error marking release as seen:', error)
    }
  }

  const handleMediaSelect = async (media: any, rating?: string, status?: string) => {
    if (!user) return

    try {
      // Create media ID format - handle both regular media and season-specific IDs
      let mediaId: string
      let tmdbId: number
      let mediaType: string

      // Check if this is already a season-specific ID (format: tv-{tmdb_id}-s{season_number})
      if (media.id && typeof media.id === 'string' && media.id.includes('-s')) {
        // Already has season-specific ID from TVSeasonCard
        mediaId = media.id
        // Extract TMDB ID from the format tv-{tmdb_id}-s{season_number}
        const idParts = media.id.split('-')
        tmdbId = parseInt(idParts[1])
        mediaType = idParts[0]
      } else {
        // Regular media without season
        mediaType = media.media_type || (media.first_air_date ? 'tv' : 'movie')
        tmdbId = typeof media.id === 'string' ? parseInt(media.id) : media.id
        mediaId = `${mediaType}-${tmdbId}`
      }

      // Fetch FULL media details from TMDB to get networks, seasons, etc.
      // For season-specific entries, we still fetch the full show data
      let fullMediaData = media
      try {
        const detailsResponse = await fetch(`/api/tmdb/${mediaType}/${tmdbId}`)
        if (detailsResponse.ok) {
          fullMediaData = await detailsResponse.json()
        }
      } catch (error) {
        console.error('Error fetching full media details:', error)
        // Fall back to basic media data if detailed fetch fails
      }

      // First, ensure media exists in database with FULL data
      const mediaPayload = {
        id: mediaId,
        tmdb_id: tmdbId,
        media_type: mediaType,
        title: media.title || media.name,
        poster_path: media.poster_path,
        backdrop_path: media.backdrop_path,
        overview: media.overview,
        release_date: safeFormatDate(media.release_date || media.first_air_date),
        vote_average: media.vote_average,
        tmdb_data: {
          ...fullMediaData,
          // Include season-specific info if available
          season_number: media.season_number,
          season_id: media.season_id
        }
      }

      console.log('Saving media with payload:', {
        id: mediaPayload.id,
        tmdb_id: mediaPayload.tmdb_id,
        media_type: mediaPayload.media_type,
        title: mediaPayload.title
      })

      const { error: mediaError } = await supabase
        .from('media')
        .upsert(mediaPayload, { onConflict: 'id' })

      if (mediaError) {
        console.error('Error saving media - Full error object:', mediaError)
        console.error('Error saving media:', {
          message: mediaError.message,
          details: mediaError.details,
          hint: mediaError.hint,
          code: mediaError.code
        })
        return // Don't proceed if media save fails
      }

      // Save rating if provided
      if (rating) {
        const { error: ratingError } = await supabase
          .from('ratings')
          .upsert({
            user_id: user.id,
            media_id: mediaId,
            rating: rating,
            my_take: null
          }, { onConflict: 'user_id,media_id' })

        if (ratingError) {
          console.error('Error saving rating:', {
            message: ratingError.message,
            details: ratingError.details,
            hint: ratingError.hint,
            code: ratingError.code
          })
        }
      }

      // Save watch status if provided
      if (status) {
        const { error: statusError } = await supabase
          .from('watch_status')
          .upsert({
            user_id: user.id,
            media_id: mediaId,
            status: status
          }, { onConflict: 'user_id,media_id' })

        if (statusError) {
          console.error('Error saving status:', {
            message: statusError.message,
            details: statusError.details,
            hint: statusError.hint,
            code: statusError.code
          })
        }
      }

      // Reload feed (keep modal open)
      loadFeed(true)
    } catch (error) {
      console.error('Error handling media selection:', error)
    }
  }

  const handlePosterClick = (media: any) => {
    setSelectedMedia(media)
    setDetailModalOpen(true)
  }

  const handleDetailModalRate = (rating: string) => {
    if (selectedMedia) {
      handleMediaSelect(selectedMedia, rating, undefined)
    }
  }

  const handleDetailModalStatus = (status: string) => {
    if (selectedMedia) {
      handleMediaSelect(selectedMedia, undefined, status)
    }
  }

  return (
    <>
      {/* Invite Code Gate for OAuth users */}
      {showInviteCodeGate && user && (
        <InviteCodeGate
          userId={user.id}
          onValidated={() => {
            setShowInviteCodeGate(false)
            setShowProfileSetup(true)
          }}
        />
      )}

      {/* Profile Setup Modal for new users */}
      {showProfileSetup && user && (
        <ProfileSetup
          userId={user.id}
          onComplete={() => {
            setShowProfileSetup(false)
            checkUser()
          }}
        />
      )}

    <div>
      {/* Header */}
      <AppHeader profile={profile} />

      {/* Main Content */}
      <div className="main-container">
        {/* Enhanced Feed */}
        <div>
          {loading && feedItems.length === 0 ? (
            <div className="flex justify-center py-8">
              <div className="w-8 h-8 border-4 border-pink-500 border-t-transparent rounded-full animate-spin"></div>
            </div>
          ) : feedItems.length > 0 ? (
            <div className="space-y-4">
              {feedItems.map((item) => {
                if (item.type === 'activity') {
                  return (
                    <ActivityCard
                      key={item.id}
                      activity={{
                        ...item,
                        activity_type: item.activityTypes?.[0] || item.activity_type,
                        activity_data: item.activityData?.[0] || item.activity_data
                      }}
                      activityTypes={item.activityTypes}
                      activityData={item.activityData}
                      onLike={handleLike}
                      onComment={handleComment}
                      onDeleteComment={handleDeleteComment}
                      onQuickRate={handleQuickRate}
                      onQuickStatus={handleQuickStatus}
                      onUserClick={(username) => router.push(`/${username}`)}
                      onMediaClick={(media) => {
                        setSelectedMedia(media)
                        setDetailModalOpen(true)
                      }}
                      userRating={item.user_rating}
                      userStatus={item.user_status}
                      currentUserId={user?.id}
                    />
                  )
                } else if (item.type === 'recommendation') {
                  return (
                    <RecommendationCard
                      key={item.id}
                      recommendation={item}
                      onAddToWantToWatch={(mediaId) => handleQuickStatus(mediaId, 'want')}
                      onRate={handleQuickRate}
                      onDismiss={handleDismissRecommendation}
                      onMediaClick={(media) => {
                        setSelectedMedia(media)
                        setDetailModalOpen(true)
                      }}
                    />
                  )
                } else if (item.type === 'release_notification') {
                  return (
                    <ReleaseNotificationCard
                      key={item.id}
                      release={item}
                      onAddToWantToWatch={(mediaId) => handleQuickStatus(mediaId, 'want')}
                      onMarkSeen={handleMarkReleaseSeen}
                      onMediaClick={(media) => {
                        setSelectedMedia(media)
                        setDetailModalOpen(true)
                      }}
                    />
                  )
                }
                return null
              })}
              
              {/* Infinite scroll sentinel */}
              {hasMore && (
                <div id="feed-sentinel" className="h-10 flex items-center justify-center">
                  {loading && (
                    <div className="w-6 h-6 border-2 border-pink-500 border-t-transparent rounded-full animate-spin"></div>
                  )}
                </div>
              )}
            </div>
          ) : (
            <div className="text-center py-8 bg-white rounded-2xl">
              <p className="text-gray-500 mb-4">No activities yet</p>
              <button
                onClick={() => setSearchOpen(true)}
                className="px-6 py-2 bg-gradient-primary text-white rounded-full font-medium hover:scale-105 transition-transform"
              >
                Start Adding Shows
              </button>
            </div>
          )}
        </div>
      </div>

      {/* Minimal Footer */}
      <Footer variant="minimal" />

      {/* Bottom Navigation */}
      <BottomNav onSearchOpen={() => setSearchOpen(true)} />

      {/* Search Modal */}
      <SearchModal
        isOpen={searchOpen}
        onClose={() => setSearchOpen(false)}
        onSelectMedia={handleMediaSelect}
        user={user}
      />

      {/* Media Detail Modal */}
      <MediaDetailModal
        isOpen={detailModalOpen}
        onClose={() => {
          setDetailModalOpen(false)
          setSelectedMedia(null)
        }}
        media={selectedMedia}
        onRate={handleDetailModalRate}
        onStatus={handleDetailModalStatus}
        user={user}
      />
    </div>
    </>
  )
}